# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import robot_info_pb2
import status_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class RegisterRobotClientRequest(google.protobuf.message.Message):
    """Messages used for RPCs to RobotController::RegisterClient/UnregisterClient."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CLIENT_ID_FIELD_NUMBER: builtins.int
    client_id: typing.Text = ...
    def __init__(self,
        *,
        client_id : typing.Optional[typing.Text] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["client_id",b"client_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["client_id",b"client_id"]) -> None: ...
global___RegisterRobotClientRequest = RegisterRobotClientRequest

class RegisterRobotClientResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    STATUS_FIELD_NUMBER: builtins.int
    ROBOT_INFO_FIELD_NUMBER: builtins.int
    @property
    def status(self) -> status_pb2.StatusProto: ...
    @property
    def robot_info(self) -> robot_info_pb2.RobotInfo: ...
    def __init__(self,
        *,
        status : typing.Optional[status_pb2.StatusProto] = ...,
        robot_info : typing.Optional[robot_info_pb2.RobotInfo] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["robot_info",b"robot_info","status",b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["robot_info",b"robot_info","status",b"status"]) -> None: ...
global___RegisterRobotClientResponse = RegisterRobotClientResponse

class ControlEntity(google.protobuf.message.Message):
    """Metadata to identify an entity in the robot controller. Entities correspond
    to instances in the configuration (eg, RobotPartInfo) and/or C++ or Python
    classes (eg, the PartController). The fields are not necessarily mutually
    exclusive (eg, control modules are owned by a part, so both can be set).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CLIENT_ID_FIELD_NUMBER: builtins.int
    PART_ID_FIELD_NUMBER: builtins.int
    CONTROL_MODULE_ID_FIELD_NUMBER: builtins.int
    client_id: typing.Text = ...
    part_id: typing.Text = ...
    control_module_id: typing.Text = ...
    def __init__(self,
        *,
        client_id : typing.Optional[typing.Text] = ...,
        part_id : typing.Optional[typing.Text] = ...,
        control_module_id : typing.Optional[typing.Text] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["client_id",b"client_id","control_module_id",b"control_module_id","part_id",b"part_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["client_id",b"client_id","control_module_id",b"control_module_id","part_id",b"part_id"]) -> None: ...
global___ControlEntity = ControlEntity

class StateMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: StateMetadata.Type.ValueType = ...  # 0
        """No extra information provided."""

        REGULAR: StateMetadata.Type.ValueType = ...  # 1
        """State generated by the current part and output at regular intervals."""

        MERGED: StateMetadata.Type.ValueType = ...  # 2
        """State merged from subordinate parts and output at regular intervals.
        See go/rcv2#merged-states for details.
        """

        IRREGULAR: StateMetadata.Type.ValueType = ...  # 3
        """State output at irregular intervals due to certain errors.
        See go/rcv2#irregular-states for details.
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        pass

    UNSPECIFIED: StateMetadata.Type.ValueType = ...  # 0
    """No extra information provided."""

    REGULAR: StateMetadata.Type.ValueType = ...  # 1
    """State generated by the current part and output at regular intervals."""

    MERGED: StateMetadata.Type.ValueType = ...  # 2
    """State merged from subordinate parts and output at regular intervals.
    See go/rcv2#merged-states for details.
    """

    IRREGULAR: StateMetadata.Type.ValueType = ...  # 3
    """State output at irregular intervals due to certain errors.
    See go/rcv2#irregular-states for details.
    """


    TYPE_FIELD_NUMBER: builtins.int
    SIGNAL_ID_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    MERGED_SOURCES_FIELD_NUMBER: builtins.int
    type: global___StateMetadata.Type.ValueType = ...
    signal_id: typing.Text = ...
    """The type of signal the payload is expected to contain (eg, "joint_state").
    This string should be unique within a given part. See `SignalIds` in
    google3/third_party/robotics/juggler/common/proto_utils/log_constants.h
    for commonly used values.
    """

    @property
    def source(self) -> global___ControlEntity:
        """The part and/or control module which output the state to the client. For
        regular states, this is the part & control module which generated the data.
        For merged states, this is the part which the state was merged *into*
        (which is also the source which outputs the merged state to the client).
        Not used for other types of states.
        """
        pass
    @property
    def merged_sources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ControlEntity]:
        """For merged states, these are the parts which the state was merged *from*.
        Not used for other types of states.
        """
        pass
    def __init__(self,
        *,
        type : typing.Optional[global___StateMetadata.Type.ValueType] = ...,
        signal_id : typing.Optional[typing.Text] = ...,
        source : typing.Optional[global___ControlEntity] = ...,
        merged_sources : typing.Optional[typing.Iterable[global___ControlEntity]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["signal_id",b"signal_id","source",b"source","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["merged_sources",b"merged_sources","signal_id",b"signal_id","source",b"source","type",b"type"]) -> None: ...
global___StateMetadata = StateMetadata

class CommandMetadata(google.protobuf.message.Message):
    """*** Robot Client fields ***"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: CommandMetadata.Type.ValueType = ...  # 0
        """No extra information provided."""

        CLIENT: CommandMetadata.Type.ValueType = ...  # 1
        """Command output from a robot client to the backend."""

        ECHOED_INPUT: CommandMetadata.Type.ValueType = ...  # 3
        """TODO: Consider renaming to CLIENT_OUTPUT.
        Input command for a control module which has already
        """

        ECHOED_OUTPUT: CommandMetadata.Type.ValueType = ...  # 4
        """been executed, echoed in the state for logging.
        Command output from a virtual part to other parts,
        """

        SPLIT_OUTPUT: CommandMetadata.Type.ValueType = ...  # 5
        """before it has been split up, echoed in the state.
        Command output from a virtual part to other parts,
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """*** Backend Framework fields ***

        These fields track and/or affect the way a command is processed by the
        backend framework. They are both set and used by the backend framework.

        """
        pass

    UNSPECIFIED: CommandMetadata.Type.ValueType = ...  # 0
    """No extra information provided."""

    CLIENT: CommandMetadata.Type.ValueType = ...  # 1
    """Command output from a robot client to the backend."""

    ECHOED_INPUT: CommandMetadata.Type.ValueType = ...  # 3
    """TODO: Consider renaming to CLIENT_OUTPUT.
    Input command for a control module which has already
    """

    ECHOED_OUTPUT: CommandMetadata.Type.ValueType = ...  # 4
    """been executed, echoed in the state for logging.
    Command output from a virtual part to other parts,
    """

    SPLIT_OUTPUT: CommandMetadata.Type.ValueType = ...  # 5
    """before it has been split up, echoed in the state.
    Command output from a virtual part to other parts,
    """


    BLOCKING_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    UPDATED_FIELD_NUMBER: builtins.int
    MIN_TIME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    PROCESSING_RESULT_FIELD_NUMBER: builtins.int
    ORIGINAL_TIME_FIELD_NUMBER: builtins.int
    blocking: builtins.bool = ...
    """These fields affect the way a command is processed by the robot client.

    Whether the command should be blocking. This is only used on the
    client end; it does not have any effect in the controller.
    """

    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Time command has to complete before being marked as failed.
        timeout == 0 means to use the default timeout (1 minute).
        timeout < 0 means infinite timeout.
        """
        pass
    updated: builtins.bool = ...
    """*** Control Module/ Device Adapter fields ***

    These fields affect the way a command is processed by a control module.
    If the plugins used do not check and use these fields, they are ignored.
    If a new field is added here, it should probably also be copied by
    utils::CopyCommandExecutionMetadata().

    Whether the command has been updated since the last control cycle.
    This field is automatically set to false each time a new control cycle
    starts and to true when a new client command is received or when
    RobotData::MutableOutputCommand() is called.
    """

    @property
    def min_time(self) -> google.protobuf.duration_pb2.Duration:
        """Minimum execution time for a command. If greater than the minimum time
        physically possible, this will slow down the motion; otherwise, it will
        not have any effect. This is primarily implemented by reflexxes.
        """
        pass
    type: global___CommandMetadata.Type.ValueType = ...
    @property
    def source(self) -> global___ControlEntity:
        """The entity which generated/output the command. For client and virtual
        commands, this is used to determine whether that entity has command
        authority for the target.
        """
        pass
    @property
    def target(self) -> global___ControlEntity:
        """The target entity for the command. For client and virtual commands, this is
        the part the command should be dispatched to. For echoed commands, this is
        the part and control module which received the command as input.
        """
        pass
    processing_result: global___ControlModuleCommandProcessing.Result.ValueType = ...
    """If type = ECHOED_INPUT, this is the result of ControlModule::ProcessCommand
    executing with this input command. While ProcessCommand is executing, this
    field contains the processing result for the *previous* control cycle. It
    is automatically updated immediately after ProcessCommand completes (ie,
    before UpdateState). If type = ECHOED_OUTPUT, this is whether the command
    was successfully output to subordinate parts. Not used for other types.
    """

    @property
    def original_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """If type = ECHOED_*, LogEntry.id.timestamp is the time the message was
        output in the state batch. Therefore the command's original timestamp
        (ie, when the payload was originally generated) is copied to this field.
        Not used for other command types.
        """
        pass
    def __init__(self,
        *,
        blocking : typing.Optional[builtins.bool] = ...,
        timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        updated : typing.Optional[builtins.bool] = ...,
        min_time : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        type : typing.Optional[global___CommandMetadata.Type.ValueType] = ...,
        source : typing.Optional[global___ControlEntity] = ...,
        target : typing.Optional[global___ControlEntity] = ...,
        processing_result : typing.Optional[global___ControlModuleCommandProcessing.Result.ValueType] = ...,
        original_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["blocking",b"blocking","min_time",b"min_time","original_time",b"original_time","processing_result",b"processing_result","source",b"source","target",b"target","timeout",b"timeout","type",b"type","updated",b"updated"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["blocking",b"blocking","min_time",b"min_time","original_time",b"original_time","processing_result",b"processing_result","source",b"source","target",b"target","timeout",b"timeout","type",b"type","updated",b"updated"]) -> None: ...
global___CommandMetadata = CommandMetadata

class SystemCommand(google.protobuf.message.Message):
    """System commands sent to the control modules/ device adapter."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: SystemCommand.Type.ValueType = ...  # 0
        ENABLE_MOTION: SystemCommand.Type.ValueType = ...  # 1
        """Triggers a state transition to enable motion. After this command, the
        robot should hold its position until a movement command is received.
        """

        DISABLE_MOTION: SystemCommand.Type.ValueType = ...  # 2
        """Stops motion and triggers a state transition to prevent further movement.
        All movements should be rejected as long as the robot is in this state.
        """

        CLEAR_FAULT: SystemCommand.Type.ValueType = ...  # 3
        """Clears any faults if possible. After this, the robot should be in the
        motion disabled state.
        """

        STOP_MOTION: SystemCommand.Type.ValueType = ...  # 4
        """Stops the current motion as quickly as possible, but without the state
        transition triggered by DISABLE_MOTION. Subsequent movements should be
        accepted as long as they are valid and the robot is not faulted. This is
        a valid command when motion is disabled (since it commands the absence
        of motion); in some cases, its implementation may be different depending
        on whether motion is enabled or disabled.
        """

        MOVE_TO_HOME: SystemCommand.Type.ValueType = ...  # 5
        """Moves the robot to its home position, defined in the config."""

        FAIL_SAFE: SystemCommand.Type.ValueType = ...  # 6
        """Instructs the device to make a best-effort attempt to protect itself from
        damage, in response to a failure or error. This is usually generated
        internally in the controller, although it can be sent directly from the
        client too. In most cases, the implementation is the same as STOP_MOTION.
        """

        RELEASE_CONTROL_AUTHORITY: SystemCommand.Type.ValueType = ...  # 7
        """Release the commanded part(s) from being under the control authority of
        the command's source. This will fail if the command's source does not
        hold that authority. Control modules and device adapters will never see
        this command directly and do not need to handle it; instead they will see
        a STOP_MOTION command. There is no command to take control authority
        because authority is automatically taken for the source of any command if
        it is available (ie, not held by another entity); a command to take
        authority would be exactly equivalent to STOP_MOTION.
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """Type of the command."""
        pass

    UNSPECIFIED: SystemCommand.Type.ValueType = ...  # 0
    ENABLE_MOTION: SystemCommand.Type.ValueType = ...  # 1
    """Triggers a state transition to enable motion. After this command, the
    robot should hold its position until a movement command is received.
    """

    DISABLE_MOTION: SystemCommand.Type.ValueType = ...  # 2
    """Stops motion and triggers a state transition to prevent further movement.
    All movements should be rejected as long as the robot is in this state.
    """

    CLEAR_FAULT: SystemCommand.Type.ValueType = ...  # 3
    """Clears any faults if possible. After this, the robot should be in the
    motion disabled state.
    """

    STOP_MOTION: SystemCommand.Type.ValueType = ...  # 4
    """Stops the current motion as quickly as possible, but without the state
    transition triggered by DISABLE_MOTION. Subsequent movements should be
    accepted as long as they are valid and the robot is not faulted. This is
    a valid command when motion is disabled (since it commands the absence
    of motion); in some cases, its implementation may be different depending
    on whether motion is enabled or disabled.
    """

    MOVE_TO_HOME: SystemCommand.Type.ValueType = ...  # 5
    """Moves the robot to its home position, defined in the config."""

    FAIL_SAFE: SystemCommand.Type.ValueType = ...  # 6
    """Instructs the device to make a best-effort attempt to protect itself from
    damage, in response to a failure or error. This is usually generated
    internally in the controller, although it can be sent directly from the
    client too. In most cases, the implementation is the same as STOP_MOTION.
    """

    RELEASE_CONTROL_AUTHORITY: SystemCommand.Type.ValueType = ...  # 7
    """Release the commanded part(s) from being under the control authority of
    the command's source. This will fail if the command's source does not
    hold that authority. Control modules and device adapters will never see
    this command directly and do not need to handle it; instead they will see
    a STOP_MOTION command. There is no command to take control authority
    because authority is automatically taken for the source of any command if
    it is available (ie, not held by another entity); a command to take
    authority would be exactly equivalent to STOP_MOTION.
    """


    TYPE_FIELD_NUMBER: builtins.int
    type: global___SystemCommand.Type.ValueType = ...
    def __init__(self,
        *,
        type : typing.Optional[global___SystemCommand.Type.ValueType] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...
global___SystemCommand = SystemCommand

class RobotCommandId(google.protobuf.message.Message):
    """Unique identifier for the command."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SEQ_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    seq: builtins.int = ...
    """Sequence number, from LogEntry.id.seq."""

    @property
    def source(self) -> global___ControlEntity:
        """Source of the command, from LogEntry.meta.command.source"""
        pass
    def __init__(self,
        *,
        seq : typing.Optional[builtins.int] = ...,
        source : typing.Optional[global___ControlEntity] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["seq",b"seq","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["seq",b"seq","source",b"source"]) -> None: ...
global___RobotCommandId = RobotCommandId

class RobotCommandResult(google.protobuf.message.Message):
    """The final result of a command output to the client after it has terminated."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMAND_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    PREEMPTED_FIELD_NUMBER: builtins.int
    @property
    def command_id(self) -> global___RobotCommandId:
        """Id of the command which terminated."""
        pass
    @property
    def status(self) -> status_pb2.StatusProto:
        """Whether and how the command failed. Both successful completion and
        preemption by another command have an Ok status.
        """
        pass
    preempted: builtins.bool = ...
    """Whether this command was preempted by another command before it completed."""

    def __init__(self,
        *,
        command_id : typing.Optional[global___RobotCommandId] = ...,
        status : typing.Optional[status_pb2.StatusProto] = ...,
        preempted : typing.Optional[builtins.bool] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["command_id",b"command_id","preempted",b"preempted","status",b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["command_id",b"command_id","preempted",b"preempted","status",b"status"]) -> None: ...
global___RobotCommandResult = RobotCommandResult

class ControlModuleCommandProcessing(google.protobuf.message.Message):
    """The intermediate result of ControlModule::ProcessCommand. These values
    (asside from FAILURE) do not indicate whether a command has terminated.
    This message is only used to scope the enum values.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Result:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ResultEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Result.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: ControlModuleCommandProcessing.Result.ValueType = ...  # 0
        BYPASS: ControlModuleCommandProcessing.Result.ValueType = ...  # 1
        """Command bypassed this control module (ie, ProcessCommand returned false)."""

        SUCCESS: ControlModuleCommandProcessing.Result.ValueType = ...  # 2
        """Command was processed successfully (ie, ProcessCommand returned true)."""

        FAILURE: ControlModuleCommandProcessing.Result.ValueType = ...  # 3
        """Command failed (ie, ControlModule::HandleCommandProcessingFailure was
        called). Details are in LogEntry.system_state.command_results.status.
        Note: the system state is in a different LogEntry message than the
        echoed input command message that contains this value in its metadata.
        """

    class Result(_Result, metaclass=_ResultEnumTypeWrapper):
        pass

    UNSPECIFIED: ControlModuleCommandProcessing.Result.ValueType = ...  # 0
    BYPASS: ControlModuleCommandProcessing.Result.ValueType = ...  # 1
    """Command bypassed this control module (ie, ProcessCommand returned false)."""

    SUCCESS: ControlModuleCommandProcessing.Result.ValueType = ...  # 2
    """Command was processed successfully (ie, ProcessCommand returned true)."""

    FAILURE: ControlModuleCommandProcessing.Result.ValueType = ...  # 3
    """Command failed (ie, ControlModule::HandleCommandProcessingFailure was
    called). Details are in LogEntry.system_state.command_results.status.
    Note: the system state is in a different LogEntry message than the
    echoed input command message that contains this value in its metadata.
    """


    def __init__(self,
        ) -> None: ...
global___ControlModuleCommandProcessing = ControlModuleCommandProcessing

class SystemState(google.protobuf.message.Message):
    """The state of the robot controller system."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMAND_RESULTS_FIELD_NUMBER: builtins.int
    DEVICE_STATUS_FIELD_NUMBER: builtins.int
    MOTION_ENABLED_FIELD_NUMBER: builtins.int
    DEVICE_FAIL_SAFE_FIELD_NUMBER: builtins.int
    ACTIVE_COMMAND_ID_FIELD_NUMBER: builtins.int
    CONTROL_STEP_TIME_SEC_FIELD_NUMBER: builtins.int
    CONTROL_STEP_TIME_EXCEEDED_FIELD_NUMBER: builtins.int
    COMMAND_SENT_FROM_CLIENT_FIELD_NUMBER: builtins.int
    COMMAND_SENT_TO_DEVICE_FIELD_NUMBER: builtins.int
    STATE_RECEIVED_FROM_DEVICE_FIELD_NUMBER: builtins.int
    @property
    def command_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RobotCommandResult]:
        """A list of recently terminated commands and whether they succeeded or
        failed. This should always have the result of the most recently terminated
        command, and may optionally have the results of earlier commands.
        """
        pass
    @property
    def device_status(self) -> status_pb2.StatusProto:
        """Whether there is a error or failure in the device."""
        pass
    motion_enabled: builtins.bool = ...
    """Whether motion is enabled in the controller and device."""

    device_fail_safe: builtins.bool = ...
    """Whether the device adapter executed a FAIL_SAFE command this control cycle.
    FAIL_SAFE commands can be explicitly given as the device adapter's input or
    caused by an invalid command or other internal error. This is primarily for
    logging; client code should rarely (if ever) need to use it directly.
    """

    @property
    def active_command_id(self) -> global___RobotCommandId:
        """The id of the active command, which comes from the meta.command.source and
        id.seq of the command sent from the client. The source sub-field of this
        message is also the current control authority. A command is considered
        active until another command is received from the client, so a command can
        simultaneously be active and terminated.
        """
        pass
    control_step_time_sec: builtins.float = ...
    """Active processing time (excluding the rate limiting sleep) of the previous
    backend control step (since the current step is still in progress when this
    is set). If this part is connected to other synchronous parts (via
    RobotPartInfo.subordinate_part_ids), this is the total time used to step
    all connected synchronous parts (but not asynchronous parts).
    """

    control_step_time_exceeded: builtins.bool = ...
    """Whether the previous control step exceeded its intended duration (ie,
    1/RobotPartInfo.control_frequency; not set if control_frequency is <= 0).
    """

    @property
    def command_sent_from_client(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamps used for profiling/debugging/system verification.

        Copy of the timestamp of the command sent from the client.
        Only set in the cycle the command began processing, otherwise empty.
        """
        pass
    @property
    def command_sent_to_device(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time recorded just before DeviceAdapter::DeviceProcessCommand is called."""
        pass
    @property
    def state_received_from_device(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time recorded just after DeviceAdapter::DeviceUpdateState is called."""
        pass
    def __init__(self,
        *,
        command_results : typing.Optional[typing.Iterable[global___RobotCommandResult]] = ...,
        device_status : typing.Optional[status_pb2.StatusProto] = ...,
        motion_enabled : typing.Optional[builtins.bool] = ...,
        device_fail_safe : typing.Optional[builtins.bool] = ...,
        active_command_id : typing.Optional[global___RobotCommandId] = ...,
        control_step_time_sec : typing.Optional[builtins.float] = ...,
        control_step_time_exceeded : typing.Optional[builtins.bool] = ...,
        command_sent_from_client : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        command_sent_to_device : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        state_received_from_device : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["active_command_id",b"active_command_id","command_sent_from_client",b"command_sent_from_client","command_sent_to_device",b"command_sent_to_device","control_step_time_exceeded",b"control_step_time_exceeded","control_step_time_sec",b"control_step_time_sec","device_fail_safe",b"device_fail_safe","device_status",b"device_status","motion_enabled",b"motion_enabled","state_received_from_device",b"state_received_from_device"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["active_command_id",b"active_command_id","command_results",b"command_results","command_sent_from_client",b"command_sent_from_client","command_sent_to_device",b"command_sent_to_device","control_step_time_exceeded",b"control_step_time_exceeded","control_step_time_sec",b"control_step_time_sec","device_fail_safe",b"device_fail_safe","device_status",b"device_status","motion_enabled",b"motion_enabled","state_received_from_device",b"state_received_from_device"]) -> None: ...
global___SystemState = SystemState
