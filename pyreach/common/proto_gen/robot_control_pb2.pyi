# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import status_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class CommandMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BLOCKING_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    UPDATED_FIELD_NUMBER: builtins.int
    MIN_TIME_FIELD_NUMBER: builtins.int
    blocking: builtins.bool
    """Whether the command should be blocking. This is only used on the
    client end; it does not have any effect in the controller.
    """

    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Time command has to execute before timing out.
        timeout == 0 means to use the default timeout (1 minute).
        timeout < 0 means infinite timeout.
        """
        pass
    updated: builtins.bool
    """Whether the command has been updated since the last control cycle."""

    @property
    def min_time(self) -> google.protobuf.duration_pb2.Duration:
        """Minimum execution time for a command. If greater than the minimum time
        physically possible, this will slow down the motion. If less than the
        minimum possible, it will have no effect. This is primarily implemented by
        reflexxes; if that isn't being used, this field will probably be ignored.
        """
        pass
    def __init__(self,
        *,
        blocking: builtins.bool = ...,
        timeout: typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        updated: builtins.bool = ...,
        min_time: typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["min_time",b"min_time","timeout",b"timeout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["blocking",b"blocking","min_time",b"min_time","timeout",b"timeout","updated",b"updated"]) -> None: ...
global___CommandMetadata = CommandMetadata

class SystemCommand(google.protobuf.message.Message):
    """System command."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SystemCommand._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSPECIFIED: SystemCommand._Type.ValueType  # 0
        ENABLE_MOTION: SystemCommand._Type.ValueType  # 1
        """Triggers a state transition to enable motion. After this command, the
        robot should hold its position until a movement command is received.
        """

        DISABLE_MOTION: SystemCommand._Type.ValueType  # 2
        """Stops motion and triggers a state transition to prevent further movement.
        All movements should be rejected as long as the robot is in this state.
        """

        CLEAR_FAULT: SystemCommand._Type.ValueType  # 3
        """Clears any faults if possible. After this, the robot should be in the
        motion disabled state.
        """

        STOP_MOTION: SystemCommand._Type.ValueType  # 4
        """Stops the current motion as quickly as possible, but without the state
        transition triggered by DISABLE_MOTION. Subsequent movements should be
        accepted as long as they are valid and the robot is not faulted. This is
        a valid command when motion is disabled (since it commands the absence
        of motion); in some cases, its implementation may be different depending
        on whether motion is enabled or disabled.
        """

        MOVE_TO_HOME: SystemCommand._Type.ValueType  # 5
        """Moves the robot to its home position, defined in the config."""

        FAIL_SAFE: SystemCommand._Type.ValueType  # 6
        """Instructs the device to make a best-effort attempt to protect itself from
        damage, in response to a failure or error. This is usually generated
        internally in the controller, although it can be sent directly from the
        client too. In most cases, the implementation is the same as STOP_MOTION.
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """Type of the command."""
        pass

    UNSPECIFIED: SystemCommand.Type.ValueType  # 0
    ENABLE_MOTION: SystemCommand.Type.ValueType  # 1
    """Triggers a state transition to enable motion. After this command, the
    robot should hold its position until a movement command is received.
    """

    DISABLE_MOTION: SystemCommand.Type.ValueType  # 2
    """Stops motion and triggers a state transition to prevent further movement.
    All movements should be rejected as long as the robot is in this state.
    """

    CLEAR_FAULT: SystemCommand.Type.ValueType  # 3
    """Clears any faults if possible. After this, the robot should be in the
    motion disabled state.
    """

    STOP_MOTION: SystemCommand.Type.ValueType  # 4
    """Stops the current motion as quickly as possible, but without the state
    transition triggered by DISABLE_MOTION. Subsequent movements should be
    accepted as long as they are valid and the robot is not faulted. This is
    a valid command when motion is disabled (since it commands the absence
    of motion); in some cases, its implementation may be different depending
    on whether motion is enabled or disabled.
    """

    MOVE_TO_HOME: SystemCommand.Type.ValueType  # 5
    """Moves the robot to its home position, defined in the config."""

    FAIL_SAFE: SystemCommand.Type.ValueType  # 6
    """Instructs the device to make a best-effort attempt to protect itself from
    damage, in response to a failure or error. This is usually generated
    internally in the controller, although it can be sent directly from the
    client too. In most cases, the implementation is the same as STOP_MOTION.
    """


    TYPE_FIELD_NUMBER: builtins.int
    type: global___SystemCommand.Type.ValueType
    def __init__(self,
        *,
        type: global___SystemCommand.Type.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...
global___SystemCommand = SystemCommand

class RobotCommandResult(google.protobuf.message.Message):
    """A message indicating how a particular command terminated."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMAND_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    command_id: builtins.int
    @property
    def status(self) -> status_pb2.StatusProto: ...
    def __init__(self,
        *,
        command_id: builtins.int = ...,
        status: typing.Optional[status_pb2.StatusProto] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["status",b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["command_id",b"command_id","status",b"status"]) -> None: ...
global___RobotCommandResult = RobotCommandResult

class SystemState(google.protobuf.message.Message):
    """A message with the state of the robot controller system."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COMMAND_RESULTS_FIELD_NUMBER: builtins.int
    DEVICE_STATUS_FIELD_NUMBER: builtins.int
    MOTION_ENABLED_FIELD_NUMBER: builtins.int
    DEVICE_FAIL_SAFE_FIELD_NUMBER: builtins.int
    ACTIVE_COMMAND_ID_FIELD_NUMBER: builtins.int
    CONTROL_STEP_TIME_SEC_FIELD_NUMBER: builtins.int
    CONTROL_STEP_TIME_EXCEEDED_FIELD_NUMBER: builtins.int
    COMMAND_SENT_FROM_CLIENT_FIELD_NUMBER: builtins.int
    COMMAND_SENT_TO_DEVICE_FIELD_NUMBER: builtins.int
    STATE_RECEIVED_FROM_DEVICE_FIELD_NUMBER: builtins.int
    @property
    def command_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RobotCommandResult]:
        """A list of recently terminated commands and whether they succeeded or
        failed. This should always have the result of the most recently terminated
        command, and may optionally have the results of earlier commands.
        """
        pass
    @property
    def device_status(self) -> status_pb2.StatusProto:
        """Whether there is a error or failure in the device."""
        pass
    motion_enabled: builtins.bool
    """Whether motion is enabled in the controller and device."""

    device_fail_safe: builtins.bool
    """Whether the device adapter executed a FAIL_SAFE command this control cycle.
    FAIL_SAFE commands can be explicitly given as the device adapter's input or
    caused by an invalid command or other internal error. This is primarily for
    logging; client code should rarely (if ever) need to use it directly.
    """

    active_command_id: builtins.int
    """The id of the active command, which comes from id.seq sent from the client.
    A command is considered active until another command is received from the
    client, so a command can simultaneously be active and terminated.
    """

    control_step_time_sec: builtins.float
    """Active processing time (excluding the rate limiting sleep) of the previous
    backend control step (since the current step is still in progress when this
    is set). If this part is connected to other synchronous parts (via
    RobotPartInfo.subordinate_part_ids), this is the total time used to step
    all connected synchronous parts (but not asynchronous parts).
    """

    control_step_time_exceeded: builtins.bool
    """Whether the previous control step exceeded its intended duration (ie,
    1/RobotPartInfo.control_frequency; not set if control_frequency is <= 0).
    """

    @property
    def command_sent_from_client(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamps used for profiling/debugging/system verification.

        Copy of the timestamp of the command sent from the client.
        Only set in the cycle the command began processing, otherwise empty.
        """
        pass
    @property
    def command_sent_to_device(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time recorded just before DeviceAdapter::DeviceProcessCommand is called."""
        pass
    @property
    def state_received_from_device(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time recorded just after DeviceAdapter::DeviceUpdateState is called."""
        pass
    def __init__(self,
        *,
        command_results: typing.Optional[typing.Iterable[global___RobotCommandResult]] = ...,
        device_status: typing.Optional[status_pb2.StatusProto] = ...,
        motion_enabled: builtins.bool = ...,
        device_fail_safe: builtins.bool = ...,
        active_command_id: builtins.int = ...,
        control_step_time_sec: builtins.float = ...,
        control_step_time_exceeded: builtins.bool = ...,
        command_sent_from_client: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        command_sent_to_device: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        state_received_from_device: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["command_sent_from_client",b"command_sent_from_client","command_sent_to_device",b"command_sent_to_device","device_status",b"device_status","state_received_from_device",b"state_received_from_device"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["active_command_id",b"active_command_id","command_results",b"command_results","command_sent_from_client",b"command_sent_from_client","command_sent_to_device",b"command_sent_to_device","control_step_time_exceeded",b"control_step_time_exceeded","control_step_time_sec",b"control_step_time_sec","device_fail_safe",b"device_fail_safe","device_status",b"device_status","motion_enabled",b"motion_enabled","state_received_from_device",b"state_received_from_device"]) -> None: ...
global___SystemState = SystemState
