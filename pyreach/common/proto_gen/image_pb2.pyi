# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class EncodedImage(google.protobuf.message.Message):
    """A descriptive proto for image storage.  This proto explicitly splits out the
    pixel description for its primitive type, number of channels, and channel
    order, where the latter two are described jointly.  The image producer
    configures the metadata for the user interpretability. Moreover, this proto
    can describe a raw image and, if/when a compression type enum is added, an
    encoded image.

    Decoding can be done via FromProto() in image_utils.h.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EncodedImage._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: EncodedImage._Type.ValueType  # 0
        """UNKNOWN is what you get when you to convert an unsupported format into an
        EncodedImage.
        """

        PNG_U8: EncodedImage._Type.ValueType  # 1
        """A color PNG image that may include an alpha channel. It is distinguished
        by the image pixel type defined in //robotics/image/pixels.h.
        """

        PNG_GRAYU8: EncodedImage._Type.ValueType  # 2
        JPG_U8: EncodedImage._Type.ValueType  # 3
        """JPGs can represent only RGB images (no alpha)."""

        JPG_GRAYU8: EncodedImage._Type.ValueType  # 4
        ROS_DEPTHF32: EncodedImage._Type.ValueType  # 5
        """The discretized-depth-encoded-as-PNG format used by ROS's
        compressed_depth_transport package. See that package's documentation for
        details.
        """

        BAYER_GRBG8: EncodedImage._Type.ValueType  # 6
        """The Bayer pattern corresponding to ROS's BAYER_GRBG8 (see
        sensor_msgs/image_encodings.h), and to OpenCV's BayerGB2<thing>.
        """

        BZIP2_PGM: EncodedImage._Type.ValueType  # 7
        """TODO:
        - GZIP_DEPTHF32
        - PNG_DEPTHU16  // Once we have DepthU16 pixels.
        - The web-friendly encoding of PNG_DEPTHU16 where R contains the top
        eight bits and G contains the bottom eight bits.
        A PGM depth image compressed in BZIP2 format.
        """

        DEPTH_16U_RVL: EncodedImage._Type.ValueType  # 8
        """Lossless RVL compression with U16 depth image."""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        pass

    UNKNOWN: EncodedImage.Type.ValueType  # 0
    """UNKNOWN is what you get when you to convert an unsupported format into an
    EncodedImage.
    """

    PNG_U8: EncodedImage.Type.ValueType  # 1
    """A color PNG image that may include an alpha channel. It is distinguished
    by the image pixel type defined in //robotics/image/pixels.h.
    """

    PNG_GRAYU8: EncodedImage.Type.ValueType  # 2
    JPG_U8: EncodedImage.Type.ValueType  # 3
    """JPGs can represent only RGB images (no alpha)."""

    JPG_GRAYU8: EncodedImage.Type.ValueType  # 4
    ROS_DEPTHF32: EncodedImage.Type.ValueType  # 5
    """The discretized-depth-encoded-as-PNG format used by ROS's
    compressed_depth_transport package. See that package's documentation for
    details.
    """

    BAYER_GRBG8: EncodedImage.Type.ValueType  # 6
    """The Bayer pattern corresponding to ROS's BAYER_GRBG8 (see
    sensor_msgs/image_encodings.h), and to OpenCV's BayerGB2<thing>.
    """

    BZIP2_PGM: EncodedImage.Type.ValueType  # 7
    """TODO:
    - GZIP_DEPTHF32
    - PNG_DEPTHU16  // Once we have DepthU16 pixels.
    - The web-friendly encoding of PNG_DEPTHU16 where R contains the top
    eight bits and G contains the bottom eight bits.
    A PGM depth image compressed in BZIP2 format.
    """

    DEPTH_16U_RVL: EncodedImage.Type.ValueType  # 8
    """Lossless RVL compression with U16 depth image."""


    class PixelType(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class _PixelPrimitive:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _PixelPrimitiveEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EncodedImage.PixelType._PixelPrimitive.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNSPECIFIED_PIXEL_PRIMITIVE: EncodedImage.PixelType._PixelPrimitive.ValueType  # 0
            UCHAR8: EncodedImage.PixelType._PixelPrimitive.ValueType  # 1
            UINT16: EncodedImage.PixelType._PixelPrimitive.ValueType  # 2
            UINT32: EncodedImage.PixelType._PixelPrimitive.ValueType  # 3
            INT32: EncodedImage.PixelType._PixelPrimitive.ValueType  # 6
            FLOAT16: EncodedImage.PixelType._PixelPrimitive.ValueType  # 4
            FLOAT32: EncodedImage.PixelType._PixelPrimitive.ValueType  # 5
        class PixelPrimitive(_PixelPrimitive, metaclass=_PixelPrimitiveEnumTypeWrapper):
            """Per channel."""
            pass

        UNSPECIFIED_PIXEL_PRIMITIVE: EncodedImage.PixelType.PixelPrimitive.ValueType  # 0
        UCHAR8: EncodedImage.PixelType.PixelPrimitive.ValueType  # 1
        UINT16: EncodedImage.PixelType.PixelPrimitive.ValueType  # 2
        UINT32: EncodedImage.PixelType.PixelPrimitive.ValueType  # 3
        INT32: EncodedImage.PixelType.PixelPrimitive.ValueType  # 6
        FLOAT16: EncodedImage.PixelType.PixelPrimitive.ValueType  # 4
        FLOAT32: EncodedImage.PixelType.PixelPrimitive.ValueType  # 5

        class _ChannelType1:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ChannelType1EnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EncodedImage.PixelType._ChannelType1.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNSPECIFIED_CHANNEL_TYPE_1: EncodedImage.PixelType._ChannelType1.ValueType  # 0
            MONO: EncodedImage.PixelType._ChannelType1.ValueType  # 1
            DEPTH: EncodedImage.PixelType._ChannelType1.ValueType  # 2
            DISPARITY: EncodedImage.PixelType._ChannelType1.ValueType  # 8
            OCCUPANCY: EncodedImage.PixelType._ChannelType1.ValueType  # 3
            BGGR: EncodedImage.PixelType._ChannelType1.ValueType  # 4
            """Bayer encoded images are single-channel and converted to color images
            using interpolation, i.e., a 1280x1024 single-channel BGGR image would
            be demosaicked to a 1280x1024 3-channel color image (BGR or RGB).
            Bayer patterns are read off in the 2x2 grid. For example:
                                 ABCD = | A | B |
                                        | C | D |
            """

            RGGB: EncodedImage.PixelType._ChannelType1.ValueType  # 5
            GBRG: EncodedImage.PixelType._ChannelType1.ValueType  # 6
            GRBG: EncodedImage.PixelType._ChannelType1.ValueType  # 7
        class ChannelType1(_ChannelType1, metaclass=_ChannelType1EnumTypeWrapper):
            pass

        UNSPECIFIED_CHANNEL_TYPE_1: EncodedImage.PixelType.ChannelType1.ValueType  # 0
        MONO: EncodedImage.PixelType.ChannelType1.ValueType  # 1
        DEPTH: EncodedImage.PixelType.ChannelType1.ValueType  # 2
        DISPARITY: EncodedImage.PixelType.ChannelType1.ValueType  # 8
        OCCUPANCY: EncodedImage.PixelType.ChannelType1.ValueType  # 3
        BGGR: EncodedImage.PixelType.ChannelType1.ValueType  # 4
        """Bayer encoded images are single-channel and converted to color images
        using interpolation, i.e., a 1280x1024 single-channel BGGR image would
        be demosaicked to a 1280x1024 3-channel color image (BGR or RGB).
        Bayer patterns are read off in the 2x2 grid. For example:
                             ABCD = | A | B |
                                    | C | D |
        """

        RGGB: EncodedImage.PixelType.ChannelType1.ValueType  # 5
        GBRG: EncodedImage.PixelType.ChannelType1.ValueType  # 6
        GRBG: EncodedImage.PixelType.ChannelType1.ValueType  # 7

        class _ChannelType3:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ChannelType3EnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EncodedImage.PixelType._ChannelType3.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNSPECIFIED_CHANNEL_TYPE_3: EncodedImage.PixelType._ChannelType3.ValueType  # 0
            BGR: EncodedImage.PixelType._ChannelType3.ValueType  # 1
            RGB: EncodedImage.PixelType._ChannelType3.ValueType  # 2
            POINT_CLOUD: EncodedImage.PixelType._ChannelType3.ValueType  # 3
        class ChannelType3(_ChannelType3, metaclass=_ChannelType3EnumTypeWrapper):
            pass

        UNSPECIFIED_CHANNEL_TYPE_3: EncodedImage.PixelType.ChannelType3.ValueType  # 0
        BGR: EncodedImage.PixelType.ChannelType3.ValueType  # 1
        RGB: EncodedImage.PixelType.ChannelType3.ValueType  # 2
        POINT_CLOUD: EncodedImage.PixelType.ChannelType3.ValueType  # 3

        class _ChannelType4:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ChannelType4EnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[EncodedImage.PixelType._ChannelType4.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            UNSPECIFIED_CHANNEL_TYPE_4: EncodedImage.PixelType._ChannelType4.ValueType  # 0
            BGRA: EncodedImage.PixelType._ChannelType4.ValueType  # 1
            RGBA: EncodedImage.PixelType._ChannelType4.ValueType  # 2
        class ChannelType4(_ChannelType4, metaclass=_ChannelType4EnumTypeWrapper):
            pass

        UNSPECIFIED_CHANNEL_TYPE_4: EncodedImage.PixelType.ChannelType4.ValueType  # 0
        BGRA: EncodedImage.PixelType.ChannelType4.ValueType  # 1
        RGBA: EncodedImage.PixelType.ChannelType4.ValueType  # 2

        PIXEL_PRIMITIVE_FIELD_NUMBER: builtins.int
        CHANNEL_TYPE_1_FIELD_NUMBER: builtins.int
        CHANNEL_TYPE_3_FIELD_NUMBER: builtins.int
        CHANNEL_TYPE_4_FIELD_NUMBER: builtins.int
        pixel_primitive: global___EncodedImage.PixelType.PixelPrimitive.ValueType
        channel_type_1: global___EncodedImage.PixelType.ChannelType1.ValueType
        channel_type_3: global___EncodedImage.PixelType.ChannelType3.ValueType
        channel_type_4: global___EncodedImage.PixelType.ChannelType4.ValueType
        def __init__(self,
            *,
            pixel_primitive: global___EncodedImage.PixelType.PixelPrimitive.ValueType = ...,
            channel_type_1: global___EncodedImage.PixelType.ChannelType1.ValueType = ...,
            channel_type_3: global___EncodedImage.PixelType.ChannelType3.ValueType = ...,
            channel_type_4: global___EncodedImage.PixelType.ChannelType4.ValueType = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["channel_oneof",b"channel_oneof","channel_type_1",b"channel_type_1","channel_type_3",b"channel_type_3","channel_type_4",b"channel_type_4"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["channel_oneof",b"channel_oneof","channel_type_1",b"channel_type_1","channel_type_3",b"channel_type_3","channel_type_4",b"channel_type_4","pixel_primitive",b"pixel_primitive"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["channel_oneof",b"channel_oneof"]) -> typing.Optional[typing_extensions.Literal["channel_type_1","channel_type_3","channel_type_4"]]: ...

    COLS_FIELD_NUMBER: builtins.int
    ROWS_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    PIXEL_TYPE_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    cols: builtins.int
    """The cols and rows fields are included to support encodings (like gzip) that
    don't include image metadata. If your encoding includes the image size,
    these should not be set, and you should use the values in the encoded form.
    """

    rows: builtins.int
    type: global___EncodedImage.Type.ValueType
    @property
    def pixel_type(self) -> global___EncodedImage.PixelType: ...
    data: builtins.bytes
    def __init__(self,
        *,
        cols: builtins.int = ...,
        rows: builtins.int = ...,
        type: global___EncodedImage.Type.ValueType = ...,
        pixel_type: typing.Optional[global___EncodedImage.PixelType] = ...,
        data: builtins.bytes = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["pixel_type",b"pixel_type","type",b"type","type_oneof",b"type_oneof"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cols",b"cols","data",b"data","pixel_type",b"pixel_type","rows",b"rows","type",b"type","type_oneof",b"type_oneof"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type_oneof",b"type_oneof"]) -> typing.Optional[typing_extensions.Literal["type","pixel_type"]]: ...
global___EncodedImage = EncodedImage

class RawImage(google.protobuf.message.Message):
    """A single image, as its raw bytes (suitable for manipulating directly; see
    FromProto in image_utils.h). The type field tells us how to interpret those
    bytes. Rather than wrapping these yourself, see FromProto in
    messages/image_utils.h.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RawImage._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: RawImage._Type.ValueType  # 0
        GRAYU8: RawImage._Type.ValueType  # 1
        GRAYF32: RawImage._Type.ValueType  # 2
        RGBU8: RawImage._Type.ValueType  # 3
        RGBAU8: RawImage._Type.ValueType  # 11
        RGBF32: RawImage._Type.ValueType  # 4
        RGBAF16: RawImage._Type.ValueType  # 13
        RGBAF32: RawImage._Type.ValueType  # 14
        BGRU8: RawImage._Type.ValueType  # 5
        BGRAU8: RawImage._Type.ValueType  # 10
        BGRF32: RawImage._Type.ValueType  # 6
        DEPTHF32: RawImage._Type.ValueType  # 7
        DEPTHF64: RawImage._Type.ValueType  # 12
        DEPTHU16: RawImage._Type.ValueType  # 9
        OCCUPANCYU8: RawImage._Type.ValueType  # 8
    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """These mirror the types in //robotics/image/pixels.h.
        Next ID: 15.
        """
        pass

    UNKNOWN: RawImage.Type.ValueType  # 0
    GRAYU8: RawImage.Type.ValueType  # 1
    GRAYF32: RawImage.Type.ValueType  # 2
    RGBU8: RawImage.Type.ValueType  # 3
    RGBAU8: RawImage.Type.ValueType  # 11
    RGBF32: RawImage.Type.ValueType  # 4
    RGBAF16: RawImage.Type.ValueType  # 13
    RGBAF32: RawImage.Type.ValueType  # 14
    BGRU8: RawImage.Type.ValueType  # 5
    BGRAU8: RawImage.Type.ValueType  # 10
    BGRF32: RawImage.Type.ValueType  # 6
    DEPTHF32: RawImage.Type.ValueType  # 7
    DEPTHF64: RawImage.Type.ValueType  # 12
    DEPTHU16: RawImage.Type.ValueType  # 9
    OCCUPANCYU8: RawImage.Type.ValueType  # 8

    COLS_FIELD_NUMBER: builtins.int
    ROWS_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    cols: builtins.int
    rows: builtins.int
    type: global___RawImage.Type.ValueType
    data: builtins.bytes
    def __init__(self,
        *,
        cols: builtins.int = ...,
        rows: builtins.int = ...,
        type: global___RawImage.Type.ValueType = ...,
        data: builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["cols",b"cols","data",b"data","rows",b"rows","type",b"type"]) -> None: ...
global___RawImage = RawImage

class TimestampedImageKind(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TIMESTAMP_FIELD_NUMBER: builtins.int
    ENCODED_IMAGE_FIELD_NUMBER: builtins.int
    RAW_IMAGE_FIELD_NUMBER: builtins.int
    @property
    def timestamp(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    @property
    def encoded_image(self) -> global___EncodedImage: ...
    @property
    def raw_image(self) -> global___RawImage: ...
    def __init__(self,
        *,
        timestamp: typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        encoded_image: typing.Optional[global___EncodedImage] = ...,
        raw_image: typing.Optional[global___RawImage] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["encoded_image",b"encoded_image","image_kind",b"image_kind","raw_image",b"raw_image","timestamp",b"timestamp"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["encoded_image",b"encoded_image","image_kind",b"image_kind","raw_image",b"raw_image","timestamp",b"timestamp"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["image_kind",b"image_kind"]) -> typing.Optional[typing_extensions.Literal["encoded_image","raw_image"]]: ...
global___TimestampedImageKind = TimestampedImageKind

class ImageSpec(google.protobuf.message.Message):
    """Specification for an image."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COLS_FIELD_NUMBER: builtins.int
    ROWS_FIELD_NUMBER: builtins.int
    ENCODED_FIELD_NUMBER: builtins.int
    PIXEL_FIELD_NUMBER: builtins.int
    RAW_FIELD_NUMBER: builtins.int
    cols: builtins.int
    rows: builtins.int
    encoded: global___EncodedImage.Type.ValueType
    @property
    def pixel(self) -> global___EncodedImage.PixelType: ...
    raw: global___RawImage.Type.ValueType
    def __init__(self,
        *,
        cols: builtins.int = ...,
        rows: builtins.int = ...,
        encoded: global___EncodedImage.Type.ValueType = ...,
        pixel: typing.Optional[global___EncodedImage.PixelType] = ...,
        raw: global___RawImage.Type.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["encoded",b"encoded","image_type",b"image_type","pixel",b"pixel","raw",b"raw"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cols",b"cols","encoded",b"encoded","image_type",b"image_type","pixel",b"pixel","raw",b"raw","rows",b"rows"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["image_type",b"image_type"]) -> typing.Optional[typing_extensions.Literal["encoded","pixel","raw"]]: ...
global___ImageSpec = ImageSpec
