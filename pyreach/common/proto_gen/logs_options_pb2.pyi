# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.descriptor_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.extension_dict
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ReachFieldOptions(google.protobuf.message.Message):
    """Proto field options for Reach logs protos. See logs.proto file for usage."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DEPRECATED_JSON_NAMES_FIELD_NUMBER: builtins.int
    INHIBIT_GO_CODEGEN_FIELD_NUMBER: builtins.int
    INHIBIT_CSHARP_CODEGEN_FIELD_NUMBER: builtins.int
    INHIBIT_PY_CODEGEN_FIELD_NUMBER: builtins.int
    CMD_DATA_TYPES_FIELD_NUMBER: builtins.int
    GO_NAME_FIELD_NUMBER: builtins.int
    PYTHON_NAME_FIELD_NUMBER: builtins.int
    LEGACY_GO_POINTER_FIELD_NUMBER: builtins.int
    LEGACY_GO_TYPE_FIELD_NUMBER: builtins.int
    LEGACY_FLATTEN_FIELD_NUMBER: builtins.int
    LEGACY_EMBED_FIELD_NUMBER: builtins.int
    @property
    def deprecated_json_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of deprecated json field names for this proto field.
        This only needs to be set if the proto->json name translation is not a
        standard camelcase conversion, and if the non-standard conversion is no
        longer used in the JSON side.

        Example:
          - a case where we would set this is eventLabels, which used to be
            in JSON as "eventlabels" but is now, correctly, "eventLabels".
            Thus, we would define deprecated_json_names = ["eventlabels"].
        """
        pass
    inhibit_go_codegen: builtins.bool = ...
    """Set to true when the Go generated code should not include this field.
    However, if the field is in DeviceData or CommandData, the field will
    still be included in the list of known device/command data types.
    """

    inhibit_csharp_codegen: builtins.bool = ...
    """Set to true when the C# generated code should not include this field."""

    inhibit_py_codegen: builtins.bool = ...
    """Set to true when the Python generated code should not include this field."""

    @property
    def cmd_data_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of CommandData known data types associated with this field."""
        pass
    go_name: typing.Text = ...
    """The field name to be used in Go.

    In general, the Go name automatically generated from the field's json name
    will work, except for things like ID, UID, and 2D, which the Go compiler
    will complain about if they are left as Id, Uid, or would just look worse
    as 2d. In this case you should specify the go_name explicitly.

    Example:
      If the field name is "session_id", and you want to leave the json name
      as "sessionId", then use go_name="SessionID". Otherwise the Go name
      would be derived from the json name as "SessionId", which would trigger
      an error from the Go compiler.
    """

    python_name: typing.Text = ...
    """The field name to be used in Python classes.

    In general, the attribute names are just privatized field names. However,
    there are a couple of exceptions like "id" and "type" that happen to be
    Python reserved words and therefore, cannot and should not be redefined.
    """

    legacy_go_pointer: builtins.bool = ...
    """Normally in Go, message fields are implemented as pointers while
    primitive fields are not. Set this in order to override this behavior.

    Do NOT use this for any new fields.
    """

    legacy_go_type: typing.Text = ...
    """The field type to be used in Go.

    Do NOT use this for any new fields. New fields should never have a
    Go type different than its proto type.
    TODO: deprecate.
    """

    legacy_flatten: builtins.bool = ...
    """Struct fields in Go are by default nested. Use this for legacy fields
    that need to be flattened.
    """

    legacy_embed: builtins.bool = ...
    """Struct fields in Go are by default nested. Use this for legacy fields
    that need to be Go embedded.
    """

    def __init__(self,
        *,
        deprecated_json_names : typing.Optional[typing.Iterable[typing.Text]] = ...,
        inhibit_go_codegen : typing.Optional[builtins.bool] = ...,
        inhibit_csharp_codegen : typing.Optional[builtins.bool] = ...,
        inhibit_py_codegen : typing.Optional[builtins.bool] = ...,
        cmd_data_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        go_name : typing.Optional[typing.Text] = ...,
        python_name : typing.Optional[typing.Text] = ...,
        legacy_go_pointer : typing.Optional[builtins.bool] = ...,
        legacy_go_type : typing.Optional[typing.Text] = ...,
        legacy_flatten : typing.Optional[builtins.bool] = ...,
        legacy_embed : typing.Optional[builtins.bool] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["go_name",b"go_name","inhibit_csharp_codegen",b"inhibit_csharp_codegen","inhibit_go_codegen",b"inhibit_go_codegen","inhibit_py_codegen",b"inhibit_py_codegen","legacy_embed",b"legacy_embed","legacy_flatten",b"legacy_flatten","legacy_go_pointer",b"legacy_go_pointer","legacy_go_type",b"legacy_go_type","python_name",b"python_name"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cmd_data_types",b"cmd_data_types","deprecated_json_names",b"deprecated_json_names","go_name",b"go_name","inhibit_csharp_codegen",b"inhibit_csharp_codegen","inhibit_go_codegen",b"inhibit_go_codegen","inhibit_py_codegen",b"inhibit_py_codegen","legacy_embed",b"legacy_embed","legacy_flatten",b"legacy_flatten","legacy_go_pointer",b"legacy_go_pointer","legacy_go_type",b"legacy_go_type","python_name",b"python_name"]) -> None: ...
global___ReachFieldOptions = ReachFieldOptions

reach_options: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.FieldOptions, global___ReachFieldOptions] = ...

legacy_flatten: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, builtins.bool] = ...
"""Set to true when all usages of this message are flattened.

If there is even one usage where this message is not flattened -- and that
means repeated fields -- then do not define this option.

Only one of {legacy_flatten, legacy_embed} may be chosen.

This has the following effect when legacy_flatten=true:
* JSON: Flattened
* Go:   Flattened, no struct generated
* C#:   Flattened, no class generated

For example:

message TopLevel {
  optional Flattened flattened = 1;
}

message Flattened {
  option (legacy_flatten) = true;

  optional string field = 1;
}

JSON:

  {"field": <value>}

Go:

  struct TopLevel {
    Field string
  }

C#:

  public class TopLevel
  {
    public string field;
  }

Do NOT use this for any new messages. New messages should never be
implemented as flattened. All fields from now onwards should be implemented
as nested by default for which no option is necessary. legacy_flatten can
NEVER be set to true at the same time as legacy_embed.
"""

legacy_embed: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, builtins.bool] = ...
"""Set to true when this message is to be embedded.

Only one of {legacy_flatten, legacy_embed} may be chosen.

This has the following effect when legacy_embed=true:
* JSON: Flattened
* Go:   Embedded struct
* C#:   Flattened, class generated. The generated class is used if there
        are repeated fields.

For example:

message TopLevel {
  optional Embed embed = 1;
  repeated Embed stuff = 2;
}

message Embed {
  option (legacy_embed) = true;

  optional string field = 1;
}

JSON:

  {"field": <value>, "stuff": [{"field": <value>}, ...]}

Go:

  struct TopLevel {
    Embed
    Stuff []*Embed
  }

  struct Embed {
    Field string
  }

C#:

  public class TopLevel
  {
    public string field;
    public Embed[] stuff;
  }

  public class Embed
  {
    public string field;
  }

Do NOT use this for any new messages. New messages should never be
implemented as embedded. All fields from now onwards should be implemented
as nested by default for which no option is necessary. legacy_embed can
NEVER be set to true at the same time as legacy_flatten.
"""

go_type_name: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, typing.Text] = ...
"""The type name to be used in Go.

In general, the Go type name automatically generated from the message's
name will work, except for things like ID, UID, and 2D, which the Go
compiler will complain about if they are left as Id, Uid, or would just
look worse as 2d. In this case you should specify the go_type_name
explicitly.

Example:
  If the message name is "Pose2d", and you want the go type name to be
  "Pose2D", then use go_type_name="Pose2D".
"""

inhibit_csharp_codegen: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, builtins.bool] = ...
"""Set to true when all usages of this message are inhibited for C#. That is,
all fields of this message are also marked as inhibit_csharp_codegen.

This is used generally for messages that a C# client will never see or
emit.
"""

inhibit_codegen: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, builtins.bool] = ...
"""Set to true to unconditionally inhibit generation of this message, for
example because the message is no longer used. We still want the message
around because logs ingestion needs it.
"""
